#include <iostream>
using namespace std;
#define int long long 
int32_t main() {
    int t;
    cin>>t;
    while(t--){
        
    }
}

//___________PRIME NUMBERS UPTO 1e5______________________________________________________________________________



const long long N=1e5+1;
vector<int>generate_primes(){
    vector<int>primes;
    vector<bool>a(N+1,true);
    a[1]=false;a[0]=false;
    for(int i=2;i<N;i++){
        if(!a[i]){
            continue;
        }
        primes.push_back(i);
        for(int j=1ll*i*i;j<=N;j+=i){
            a[j]=false;
        }
    }
    return primes;
}


//___________________SPF(Smallest prime factor)_______________________________________________________________

//Used to easily generate the factors of any number.

// Say i need factores of 36. I ask spf of 36. it is 2. so 36/=2 gives 18. now spf of 18 will give 2 and num becomes 9. now spf of 9 is 3 and 
//num becomes 3. now spf of 3 is 3 and num becomes 1. STOP.
// Thus we got all prime factors of number 36 i.e 2x2x3x3.


const int MAXN=1e6+5;
int spf[MAXN];

void pre(){
    for(int i=0;i<=MAXN;i++){
        spf[i]=i;
    }
    for(int i=2;i<=MAXN;i++){
        if(spf[i]==i){
            for(int j=1ll*i*i;j<=MAXN;j+=i){
                if(spf[j]==j){
                    spf[j]=i;
                }
            }
        }
    }
}

// inside main logic

while(x!=1){
    v.pb(spf[x]);
    x/=spf[x];
}




//_____________CALCULATING LOG(N)______________________________________________________________________________________



int calclog(int n){
    int cnt=0;
    while(n>0){
        cnt++;
        n=n>>1;
    }
    return cnt; // this will return 1 greater than the log i.e the farthest set bit
}

//______________CALCULATING POWER (MODULAR EXPONENTIATION)______________________________________________________________________________________





#define int long long 

const int MOD = 1e9 + 7

int power(int base, int exp, int mod) {
    int result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {  // If exponent is odd, multiply base with result
            result = (result * base) % mod;
        }
        base = (base * base) % mod;  // Square the base
        exp /= 2;  // Reduce exponent by half
    }
    return result;
}

// (a-b)%mod = ((a-b)%mod+mod)%mod


// Function to calculate (a / b) % mod
int mod_divide(int a, int b, int mod) {
    int b_inv = power(b, mod - 2, mod);  // Compute b^(-1) using Fermat's theorem
    return (a * b_inv) % mod;
}

//_____________________FACTORIALS_ AND NCR________________________________________________________________________________________



const int mod = 1e9 + 7;
const int MAXN = 1e5 + 5; // Adjust based on max value of n you'll use

vector<int> fact(MAXN), inv_fact(MAXN);

// Binary exponentiation: a^b % mod
int power(int a, int b) {
    int res = 1;
    a %= mod;
    while (b > 0) {
        if (b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}

// Precompute factorials and inverse factorials
void precompute_factorials() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = (fact[i - 1] * i) % mod;
    }

    inv_fact[MAXN - 1] = power(fact[MAXN - 1], mod - 2); // Fermat's Little Theorem
    for (int i = MAXN - 2; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % mod;
    }
}

// ✅ Reusable function to compute nCr % mod
int nCr(int n, int r) {
    if (r < 0 || r > n) return 0;
    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;
}


//_____________Leftmost set bit____________________________________________________________________________________________

int log2_floor(int x) {
    return 31 - __builtin_clz(x);
}
// To calculte the highest power of 2<=x i.e it return the highest value of p such that (2^p <= x)

//_____________________Checking if n is prime or not(Miller Rabin Test)_____________________________________________________

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

// Modular multiplication: (a * b) % mod
ll mulmod(ll a, ll b, ll mod) {
    return (a % mod) * (b % mod) % mod;
}

// Modular exponentiation: (a^b) % mod
ll power(ll a, ll b, ll mod) {
    ll result = 1;
    a %= mod;
    while (b > 0) {
        if (b & 1) result = mulmod(result, a, mod);
        a = mulmod(a, a, mod);
        b >>= 1;
    }
    return result;
}

// Miller-Rabin primality test
bool isPrime(ll n) {
    if (n < 2) return false;
    if (n <= 3) return true;
    if (n % 2 == 0) return false;

    // Write n-1 as 2^r * d
    ll d = n - 1, r = 0;
    while (d % 2 == 0) {
        d /= 2;
        r++;
    }

    // Test with deterministic bases for n ≤ 1e9
    vector<int> bases = {2, 3};
    for (int a : bases) {
        if (a >= n) continue;
        ll x = power(a, d, n);
        if (x == 1 || x == n - 1) continue;

        bool witness = true;
        for (int i = 1; i < r; i++) {
            x = mulmod(x, x, n);
            if (x == n - 1) {
                witness = false;
                break;
            }
        }
        if (witness) return false;
    }
    return true;
}

