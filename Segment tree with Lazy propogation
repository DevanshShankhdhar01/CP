#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

#define int long long
#define fori(a,b,c) for(int i=a;i<b;i+=c)
#define forj(a,b,c) for(int j=a;j<b;j+=c)

#define vi vector<int>
#define vvi vector<vector<int>>
#define vii vector<pair<int,int>>
#define pii pair<int,int>

#define pqmini priority_queue<int, vector<int>, greater<int>>
#define pqminpi priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>


#define srt(v) sort((v).begin(), (v).end())     
#define rsrt(v) sort((v).rbegin(), (v).rend())  
bool customsort(const pair<int, int>& a, const pair<int, int>& b) {
    if (a.first == b.first) return a.second < b.second; // Ascending by second
    return a.first > b.first; // Descending by first
}


#define pb push_back
#define yes cout << "YES\n";
#define no cout << "NO\n";

#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (1ll*(a) * (b / gcd(a, b)))

#define setbits(x) __builtin_popcountll(x) // Count set bits
#define clz(x) __builtin_clzll(x)   // Count leading zeroes
#define ctz(x) __builtin_ctzll(x)   // Count trailing zeroes

template<typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

template<typename T>
using ordered_multiset = tree<pair<T,int>, null_type, less<pair<T,int>>, rb_tree_tag,tree_order_statistics_node_update>;

class segmentTree{
    
public:
    int n;
    vector<int>seg,lazy;
    
    // Initialize with size
    
    segmentTree(int size){
        n=size;
        seg.resize(4*n,0);  // 4*n is enough space for the tree
        lazy.resize(4*n,0);
    }
    
    // Build the tree from an input array
    
    void build(int node,vector<int>&arr,int low,int high){
        
        if(low==high){
            seg[node]=arr[low];
            return;
        }
        int mid=low+(high-low)/2;
        
        build(2*node+1,arr,low,mid);
        build(2*node+2,arr,mid+1,high);
        
        seg[node]=(seg[2*node+1]+seg[2*node+2]); // change to min/max/gcd etc. if needed
        
    }
    
    // Query in range [l, r]
    int query(int node,int low,int high,int l,int r){
        
        if(lazy[node] != 0) {
            seg[node] += 1ll*lazy[node]*(high-low+1);
            if(low != high) {
                lazy[2*node+1] += lazy[node];
                lazy[2*node+2] += lazy[node];
            }
            lazy[node] = 0;
        }
        
        // No overlap
        if(r<low || l>high){ 
            return 0;
        }
        
        // Complete overlap
        if(l<=low && r>=high){ 
            return seg[node];
        }
        
        //partial overlap
        int mid=low+(high-low)/2;
        
        int left=query(2*node+1,low,mid,l,r);
        int right=query(2*node+2,mid+1,high,l,r);
        
        return (left+right);
    }
    
    // Point update: set arr[ind] = val
    void update(int node,int low,int high,int ind,int val){
        if(lazy[node] != 0){
            seg[node] += lazy[node] * (high-low+1);
            if(low != high){
                lazy[2*node+1] += lazy[node];
                lazy[2*node+2] += lazy[node];
            }
            lazy[node] = 0;
        }
        if(low==high){
            seg[node]=val;
            return;
        }
        
        int mid=low+(high-low)/2;
        
        if(ind<=mid){
            update(2*node+1,low,mid,ind,val);
        }
        else{
            update(2*node+2,mid+1,high,ind,val);
        }
        seg[node]=(seg[2*node+1]+seg[2*node+2]);
    }
    // Range update
    
    void rangeupdate(int node,int low,int high,int start,int end,int val){
         if(lazy[node] != 0){
            seg[node] += lazy[node] * (high - low + 1);
            if(low != high){
                lazy[2*node+1] += lazy[node];
                lazy[2*node+2] += lazy[node];
            }
            lazy[node] = 0;
        }
        if(start>high || end<low){
            return;
        }
        if(start <= low && end >= high){
            seg[node] += 1ll*val * (high - low + 1);
            if(low != high){
                lazy[2*node+1] += val;
                lazy[2*node+2] += val;
            }
            return;
        }
        else{
            int mid=low+(high-low)/2;
            rangeupdate(2*node+1,low,mid,start,end,val);
            rangeupdate(2*node+2,mid+1,high,start,end,val);
            seg[node] = seg[2*node+1] + seg[2*node+2];
        }
        
    }
};

















