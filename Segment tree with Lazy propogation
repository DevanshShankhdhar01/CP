
class segmentTree{
    
public:
    int n;
    vector<int>seg,lazy;
    
    // Initialize with size
    
    segmentTree(int size){
        n=size;
        seg.resize(4*n,0);  // 4*n is enough space for the tree
        lazy.resize(4*n,0);
    }
    
    // Build the tree from an input array
    
    void build(int node,vector<int>&arr,int low,int high){
        
        if(low==high){
            seg[node]=arr[low];
            return;
        }
        int mid=low+(high-low)/2;
        
        build(2*node+1,arr,low,mid);
        build(2*node+2,arr,mid+1,high);
        
        seg[node]=(seg[2*node+1]+seg[2*node+2]); // change to min/max/gcd etc. if needed
        
    }
    
    // Query in range [l, r]
    int query(int node,int low,int high,int l,int r){
        
        if(lazy[node] != 0) {
            seg[node] += 1ll*lazy[node]*(high-low+1);
            if(low != high) {
                lazy[2*node+1] += lazy[node];
                lazy[2*node+2] += lazy[node];
            }
            lazy[node] = 0;
        }
        
        // No overlap
        if(r<low || l>high){ 
            return 0;
        }
        
        // Complete overlap
        if(l<=low && r>=high){ 
            return seg[node];
        }
        
        //partial overlap
        int mid=low+(high-low)/2;
        
        int left=query(2*node+1,low,mid,l,r);
        int right=query(2*node+2,mid+1,high,l,r);
        
        return (left+right);
    }
    
    // Point update: set arr[ind] = val
    void update(int node,int low,int high,int ind,int val){
        if(lazy[node] != 0){
            seg[node] += lazy[node] * (high-low+1);
            if(low != high){
                lazy[2*node+1] += lazy[node];
                lazy[2*node+2] += lazy[node];
            }
            lazy[node] = 0;
        }
        if(low==high){
            seg[node]=val;
            return;
        }
        
        int mid=low+(high-low)/2;
        
        if(ind<=mid){
            update(2*node+1,low,mid,ind,val);
        }
        else{
            update(2*node+2,mid+1,high,ind,val);
        }
        seg[node]=(seg[2*node+1]+seg[2*node+2]);
    }
    // Range update
    
    void rangeupdate(int node,int low,int high,int start,int end,int val){
         if(lazy[node] != 0){
            seg[node] += lazy[node] * (high - low + 1);
            if(low != high){
                lazy[2*node+1] += lazy[node];
                lazy[2*node+2] += lazy[node];
            }
            lazy[node] = 0;
        }
        if(start>high || end<low){
            return;
        }
        if(start <= low && end >= high){
            seg[node] += 1ll*val * (high - low + 1);
            if(low != high){
                lazy[2*node+1] += val;
                lazy[2*node+2] += val;
            }
            return;
        }
        else{
            int mid=low+(high-low)/2;
            rangeupdate(2*node+1,low,mid,start,end,val);
            rangeupdate(2*node+2,mid+1,high,start,end,val);
            seg[node] = seg[2*node+1] + seg[2*node+2];
        }
        
    }
};

















